# Sketch 概述

[论文A Survey...](https://blog.csdn.net/m0_54947284/article/details/131199953?spm=1001.2014.3001.5501)

鉴于网络流的**海量、高速、不可预测**特征，sketch被应用在测量节点中来近似记录流的频率和基数。这通过维护计数器数组来实现。

## 引入

需要记录的信息有：

- 流基数：流的数量
- 流大小：单流的数据包数量
- 流体积：特定流量的体积
- 时间信息

一般 sketch 的设计从三个角度考虑：

- 基于 sketch 网络测量的准备
- sketch 数据结构的优化
- 后处理级别的优化

## 基于 sketch 的网络测量

一般有两种方法:

- 主动测量：通过主动发送探针数据包来测量网络性能，可以测量网络延时、丢包率等等。优点是比较灵活，缺点是可能干扰网络正常运行
- 被动测量：通过监控网络流量来测量网络性能，可以测量网络流量、流量分布等，可以检测异常流量模式

### 被动测量的挑战

- 资源限制：因为网络流量通常快速庞大，测量需要足够快。因此，期望使用 SRAM 来统计，然而 SRAM 的容量有限
- 不可预测性：象流通常比鼠流更重要，为了记录象流的特征，需要足够大的计数器，然而事先难以预测象流会有多大

### 网络测量性能要求

- 高准确性：现有方法有一定误差，给出置信度。通过优化更新策略和多层 sketch 方法可以提高准确性
- 内存有效利用：大量的流会耗费大量的内存，需要通过优化采样策略来减少内存占用
- 实时响应：Counter Braids在查询特定流之前，必须提前获取所有流的信息，解码需要在线下以一种批处理方式执行。查询速度极大减慢（不懂 Counter Braids）
- 快速单包处理：速率上的挑战要求在 TCAM 或 SRAM 上完成处理。软件实现可以基于 SDN 或 NFV（网络功能虚拟化）
- 分布式可拓展性：单设备资源有限，需要多设备协同工作
- 通用性：为了适配不同的测量任务，需要设计通用的算法
- 可逆性：传统 sketch 不能从计数器反向获得流标签，需要方法实现

### sketch 是完美选择

分布式节点收集统计信息，控制器收集信息合并结果。

为了在小的内存中统计数据，sketch 牺牲了一些准确性，转而采用哈希特征键的方式来统计流量。

### 以 Count-Min sketch 为例

有 d 个计数器数组，对于一个 key，使用 d 个不同的哈希函数，同时映射到每个数组的一个计数器上，递增计数器。最后查询时，取 d 个计数器的最小值。

不难理解，这个方案提供了比较高的精度，因为尽最大努力避免其他流的干扰。

## 网络测量准备

为了减少测量的开销，需要对流量数据包进行预处理。

### 测量环境准备

- 监控器位置：为了提高流量覆盖率和测量成本，需要考虑监控器位置。包括无动力情况下的最优防止策略、有动力情况下的测量激活策略
- 流量重定向：由于流量特征和测量任务的变化，可能需要改变流量的路径，需要进行流量重定向
- 流分布/分配：为了实现负载均衡等目的，需要利用哈希等方法对流量进行分布和分配

### 测量数据准备

需要一些方法减少测量的开销：

#### 流量采样

- 流采样：在每个流中，依概率采样数据包
- 包采样：在所有数据包中，依概率采样数据包
- 线性采样：可能会丢失一些流量信息，也可能多次采样同一流

一般来说，对于小流以高概率采样，对于大流以低概率采样。有多种采样方案，从均匀采样，到自适应采样，再到分离估计桶策略，估计的精度逐渐提高。

#### 随机化处理

（看不懂作者在写什么）使用随机化方法来更新计数器

#### 批处理

相当于加一层缓存，从而可以支持把 sketch 存放到速度慢些的存储器中，减少资源的消耗

## sketch 结构的优化

分为 3 个方面

### 哈希策略

#### 传统的基于哈希的数据结构

- CM Sketch：多个计数器取最小值
- Bloom Filter：快速判断不存在
- Counting Bloom Filter：记录出现次数，支持删除
- Cuckoo Filter：快速判断存在
- Group Testing：多个项目合成一个组，找出活跃的项目
- Fast Sketch：将每个数据包哈希到几行，递增第一个计数器，然后还根据流量商的位递增计数器（不懂）
- SketchLearn：使用位映射从多级sketch中提取大流量，为小流量留下剩余计数器，形成高斯分布
- XY-Sketch：研究分解重组框架，将项目频率估计转换成概率估计

对于基数估计，可以使用 Bitmap、PCSA、LogLog、HyperLogLog、HLL-TailCut+、Sliding HyperLogLog 等方法

Zhou 等人提出一个广义的 sketch 框架，包括 bSketch（基于计数布隆过滤器）、cSketch（基于 Count-Min）、vSketch（基于内存共享机制），希望把 sketch 设计纳入一个通用的实现结构。

#### 基于学习的映射

通过 k 均值聚类和神经网络等方式，降低开销，提高精度。虽然，可能需要大量的计算资源。

### 计数器层优化

计数器位数的设计，需要兼顾小流和大流的统计

#### 小计数器用于更大范围

例如试图使用对数概率的方式来用小的空间统计大的流量

#### 虚拟寄存器用于基数估计

包括寄存器共享和比特共享

#### 偏度流量的分层计数器共享

为了避免因为象流的存在而导致的计数器浪费，使用多层计数器结构，高层的计数器基于多个低层计数器虚拟实现，从而高层计数器相对庞大，但占用的空间较小

#### 可变宽度计数器为空间效率

想办法设计数据结构支持调整计数器的宽度

#### 为更少的内存访问进行的优化

例如使用缓存

#### 计数器更新策略为了更好的精度

保守地递增计数器，甚至引入衰减机制和小值计数器驱逐机制，从而保留象流信息，丢弃鼠流信息

#### 为各种功能增加插槽

给计数器增加一些字段来存放时间戳等信息，可以支持更多的功能

### Sketch 层优化

这都啥啊...

#### 多层次组合

- 熵估计
- 可逆设计
- 全局 sketching

#### 多 sketch 组合

- 内存效率
- 大小流分离
- 包过滤

#### 滑动窗口设计

需要一些方法放弃放弃旧的流量信息，减少对于统计的影响

## 后处理级别的优化

为了把信息从 sketch 中提取出来，需要一些后处理的方法

### sketch 压缩和合并技术

目标是减少发送给收集器的数据体积，并且保持数据的完整性

#### Sketch 压缩

看不懂

#### Sketch 合并

由于每个机器上可能为同一个流分配了不同的计数器位数，需要根据流遍历这些计数器

### 流键提取技术

#### 流键可逆技术

有些方案可以支持通过计数器反向获得流标签

#### 基于概率理论的技术

把计数器抽象成随机变量，使用概率论来估计流量。包括贝叶斯理论和最大似然估计

#### 机器学习技术

通过从 sketch 本身选取一组特征，结合机器学习技术来重新制定测量任务，从而动态调整 sketch 模型

## 应用和实现

### 测量任务

- 持续性检测：短期频率不高，但持久出现的流量。例如长期进行攻击的主机
- 流延迟
- 单流测量：测量流大小和流体积
- 基数估计：不同流的数量
- 超级传播者：某个节点向大量不同 IP 和端口发送数据包
- 大流量检测：检测流量超过一定阈值的流（Heavy Hitters 不知道理解是否准确）
- 层次大流量检测：把流量分层次进行聚合，从而检测大流量（HHH）
- Top-K 流量检测：检测流量最大的 K 个流
- 熵估计：利用流量分布的熵，可以做异常检测、流量聚类等
- 变化检测：探测象流的出现和变化
- 突变检测：事件到来率的突增
- 持续 sketch：持久化全量信息
- 项目批处理检测：考虑数据流中一段时间内相同项目的连续序列，用于缓存、突发检测等

### 硬件或软件实现

- SRAM：资源有限，考虑使用以下方案
  - Single Counter Compression
  - Sampling Strategy
  - Bit-Sharing Strategy
  - Counter-Sharing Strategy
  - Virtual Estimators
- DRAM：太慢，考虑混合 SRAM
- hybrid SRAM-DRAM：解决单流测量问题
- FPGA：可以编程为快速模式匹配
- TCAM：速度很快
- 可编程交换机：使用 P4 语言进行编程
- Open vSwitch：一种多层虚拟交换机
- SDN：软件定义网络
